from typing import Dict, Any
from google import genai
from google.genai.types import Content, GenerateContentConfig, Part
from fastapi import HTTPException
import re
import uuid
import os

from app.core.config import settings
from app.core.models import ConceptRequest, TranscriptEditRequest, TranscriptExtendRequest
from .prompts import PromptGenerator
from .validator import TranscriptValidator

# Add a constant for WPM
WORDS_PER_MINUTE = 150
TRANSCRIPT_DIR = "generated_transcripts" # Define storage directory

class TranscriptGenerator:
    def __init__(self):
        """Initialize the TranscriptGenerator with Gemini client."""
        self.client = genai.Client(
            project=settings.PROJECT_ID,
            location="us-central1",
            vertexai=True
        )
        self.validator = TranscriptValidator()
        self.max_retries = 2 # Define max retries for generation

    async def generate(self, request: ConceptRequest) -> Dict[str, Any]:
        """
        Generate a podcast transcript based on the concept request, with validation retries.
        
        Args:
            request: ConceptRequest containing podcast parameters
            
        Returns:
            Dict: Containing generated transcript and word count
            
        Raises:
            HTTPException: If generation or validation fails after retries
        """
        if len(request.character_names) != request.num_speakers:
            raise HTTPException(status_code=400, detail="Number of speakers must match number of character names")

        # --- Clean Character Names --- 
        # Strip whitespace from character names before using them
        cleaned_character_names = [name.strip() for name in request.character_names]
        # Update the request object in place (if mutable) or create a new one if needed.
        # Assuming request object allows modification for simplicity. If not, adjust accordingly.
        request.character_names = cleaned_character_names 
        # --- End Clean Character Names ---

        base_prompt_text = PromptGenerator.create_podcast_prompt(request)
        initial_enhancement = (
            "\n\nIMPORTANT INSTRUCTION: Ensure that the generated transcript includes dialogue "
            # Use cleaned names in the prompt enhancement as well
            f"from ALL of the following characters: {', '.join(request.character_names)}. " 
            "Each character should have at least one speaking line."
        )
        
        current_prompt = base_prompt_text + initial_enhancement
        last_error = None

        for attempt in range(self.max_retries + 1):
            try:
                # Configure generation parameters
                config = GenerateContentConfig(
                    max_output_tokens=8192,
                )

                # Generate content using Gemini
                print(f"--- Attempt {attempt + 1} ---") # Log attempt number
                # print(f"Prompt:\\n{current_prompt}\\n---") # Optional: Log the prompt being used
                response = self.client.models.generate_content(
                    model="gemini-2.0-flash-001",
                    contents=[Part(text=current_prompt)],
                    config=config
                )

                # Extract transcript
                if not response.candidates or not response.candidates[0].content.parts:
                    raise ValueError("No transcript generated by the model")
                    
                transcript = response.candidates[0].content.parts[0].text.strip()
                
                # Validate transcript
                self.validator.validate_transcript(transcript, request)
                
                # --- If validation successful ---
                word_count = len(re.findall(r'\w+', transcript))
                estimated_duration_minutes = round(word_count / WORDS_PER_MINUTE, 2) if WORDS_PER_MINUTE > 0 else 0

                # --- Save transcript to file ---
                file_id = None # Initialize file_id
                try:
                    os.makedirs(TRANSCRIPT_DIR, exist_ok=True) # Create directory if it doesn't exist
                    file_id = str(uuid.uuid4())
                    file_path = os.path.join(TRANSCRIPT_DIR, f"{file_id}.txt")
                    with open(file_path, 'w', encoding='utf-8') as f:
                        f.write(transcript)
                    print(f"Transcript saved successfully to: {file_path}") # Log saving
                except IOError as e:
                    # Log error but don't fail the whole process if saving fails
                    print(f"Warning: Failed to save transcript to file: {e}")
                    file_id = None # Reset file_id if saving failed
                # --- End save transcript ---

                return {
                    "transcript": transcript,
                    "word_count": word_count,
                    "estimated_duration_minutes": estimated_duration_minutes,
                    "file_id": file_id # Add file_id to the response
                }

            except ValueError as ve: # Catch validation errors specifically
                last_error = str(ve)
                print(f"Validation failed on attempt {attempt + 1}: {last_error}")
                if attempt < self.max_retries:
                    print("Retrying with corrective prompt...")
                    # --- Create Corrective Prompt ---
                    correction_instruction = (
                        "\n\n--- CORRECTION REQUEST ---\n"
                        f"The previous generation attempt failed validation with the following error: '{last_error}'.\\n"
                        f"Please pay close attention to all formatting rules (especially 'SpeakerName: Text' on a single line) "
                        f"and content requirements (like including all speakers: {', '.join(request.character_names)}).\\n"
                        f"Regenerate the entire transcript, ensuring the output corrects this specific issue and meets all original instructions."
                        "\n--- END CORRECTION ---"
                    )
                    # Use the *original* base prompt plus the initial enhancement and the new correction
                    current_prompt = base_prompt_text + initial_enhancement + correction_instruction
                else:
                    print("Max retries reached. Failing generation.")
                    raise HTTPException(status_code=500, detail=f"Failed to generate a valid transcript after {self.max_retries + 1} attempts. Last error: {last_error}")

            except Exception as e:
                # Catch other potential errors (API issues, etc.)
                print(f"An unexpected error occurred during generation attempt {attempt + 1}: {str(e)}")
                # Decide if you want to retry on all exceptions or just validation errors
                # For now, we'll raise immediately for non-validation errors
                raise HTTPException(status_code=500, detail=f"Error during transcript generation: {str(e)}")

        # This part should technically be unreachable if logic is correct, but as a safeguard:
        raise HTTPException(status_code=500, detail=f"Failed to generate transcript after {self.max_retries + 1} attempts. Last validation error: {last_error}")

    async def edit(self, request: TranscriptEditRequest) -> Dict[str, Any]:
        """
        Process edited transcript, extract characters, and calculate word count.
        
        Args:
            request: TranscriptEditRequest containing edited transcript
            
        Returns:
            Dict containing processed transcript, character list, and word count
        """
        try:
            # Extract unique character names from transcript
            characters = set()
            for line in request.transcript.split('\n'):
                if ':' in line:
                    # Handle potential errors if line doesn't split correctly
                    parts = line.split(':', 1)
                    if len(parts) > 0:
                        character = parts[0].strip()
                        if character: # Ensure character name is not empty
                            characters.add(character)
            
            # Calculate word count
            word_count = len(re.findall(r'\w+', request.transcript))
            # Calculate estimated duration
            estimated_duration_minutes = round(word_count / WORDS_PER_MINUTE, 2) if WORDS_PER_MINUTE > 0 else 0

            return {
                "success": True,
                "transcript": request.transcript,
                "characters": list(characters),
                "word_count": word_count,
                "estimated_duration_minutes": estimated_duration_minutes
            }
        except Exception as e:
            print(f"Error processing edited transcript: {str(e)}") # Log edit errors too
            raise HTTPException(status_code=500, detail=str(e))

    async def extend(self, request: TranscriptExtendRequest) -> Dict[str, Any]:
        """
        Extend an existing podcast transcript to meet a target duration.
        
        Args:
            request: TranscriptExtendRequest containing the current transcript,
                     target duration, and character names.
            
        Returns:
            Dict: Containing the extended transcript and updated metrics.
            
        Raises:
            HTTPException: If extension or validation fails
        """
        try:
            # Basic validation
            if not request.transcript or not request.characters:
                raise ValueError("Current transcript and characters are required for extension.")
            if request.target_duration_minutes <= 0:
                raise ValueError("Target duration must be positive.")

            # --- Prompt Engineering for Extension ---
            prompt = (
                f"Continue the following podcast conversation. The goal is to extend it "
                f"so the total estimated duration is around {request.target_duration_minutes} minutes "
                f"(assuming {WORDS_PER_MINUTE} words per minute). Maintain the existing characters, tone, and topic.\n\n"
                f"Characters involved: {', '.join(request.characters)}. Ensure all these characters continue to participate.\n\n"
                f"Existing Transcript:\n"
                f"--------------------\n"
                f"{request.transcript.strip()}\n"
                f"--------------------\n\n"
                f"Continue the conversation naturally from here, adding more dialogue turns:"
            )

            # Configure generation parameters
            config = GenerateContentConfig(
                max_output_tokens=8192, 
            )

            # Generate content using Gemini
            response = self.client.models.generate_content(
                model="gemini-2.0-flash-001", 
                contents=[Part(text=prompt)],
                config=config
            )

            # Extract the *additional* transcript generated
            if not response.candidates or not response.candidates[0].content.parts:
                raise ValueError("No additional transcript generated for extension")
                
            additional_transcript_part = response.candidates[0].content.parts[0].text.strip()

            # Combine original and new parts
            extended_transcript = request.transcript.strip() + "\n" + additional_transcript_part

            # --- Validation (Optional but recommended) ---
            # Re-validating the extended transcript might be complex as it requires
            # adapting the ConceptRequest or validator logic. For now, we skip strict re-validation.

            # Calculate word count and duration for the *full* extended transcript
            word_count = len(re.findall(r'\w+', extended_transcript))
            estimated_duration_minutes = round(word_count / WORDS_PER_MINUTE, 2) if WORDS_PER_MINUTE > 0 else 0

            return {
                "success": True,
                "transcript": extended_transcript,
                "word_count": word_count,
                "estimated_duration_minutes": estimated_duration_minutes
            }

        except ValueError as ve:
             print(f"Validation Error extending transcript: {str(ve)}")
             raise HTTPException(status_code=400, detail=str(ve))
        except Exception as e:
            print(f"Error extending transcript: {str(e)}")
            raise HTTPException(status_code=500, detail=str(e)) 